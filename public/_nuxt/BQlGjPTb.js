import{bH as g,bI as f,bJ as C,bs as I,aY as O,i as P,n as b,R as T,s as M}from"./C_3eNykI.js";function v(){let e=[];return{cleanup:()=>{e=e.filter(r=>(r(),!1))},onCleanup:r=>{e.push(r)}}}function L(e){let t=()=>{};const n=new Promise(o=>{t=()=>{e(),o()}});return{promise:n,resolvePromise:t,onResolvedPromise:o=>{n.then(o)}}}function _(e){const t=e.effect.fn,n=e.render;e.render=(...r)=>{e.effect.fn=()=>n(...r);const o=e.effect.run();return e.effect.fn=t,e.render=n,o}}const k=e=>typeof e=="function",R=e=>e!==null&&typeof e=="object";function d(e,t){if(g(e)&&(t(e),e.children!==null)){if(Array.isArray(e.children)){e.children.forEach(n=>d(n,t));return}R(e.children)&&Object.keys(e.children).forEach(n=>{if(!k(e.children[n]))return;const r=e.children[n]();if(Array.isArray(r)){r.forEach(o=>d(o,t));return}d(r,t)})}}function W(e){var t,n;return((t=e.type)==null?void 0:t.__asyncLoader)&&((n=e.type)==null?void 0:n.name)==="AsyncComponentWrapper"}function A({subTree:e},t){const n=[];if(d(e,r=>{W(r)&&n.push(r.type.__asyncLoader())}),n.length>0){Promise.all(n).then(t);return}t()}function N(e){if(!e||!e.subTree)return;const t=e.subTree.el,n=e.u;e.u===null&&(e.u=[]),e.u.push(()=>{e.subTree.el===null&&(e.subTree.el=t),e.u=n})}function j(){const e=f();if(!e||e.isMounted)throw new Error("useLazyHydration must be called from the setup method.");const t=e.vnode.el!==null;if(e.vnode.type.__isLazilyHydrated=!0,!t)return{willPerformHydration:t,onHydrated:()=>{}};const{cleanup:n,onCleanup:r}=v(),{promise:o,resolvePromise:s,onResolvedPromise:i}=L(n),a=c=>i(()=>O(()=>A(e,c)));return e.type.__asyncLoader=()=>o,N(e.parent),C(()=>{e.asyncDep=new Promise(c=>{c(!0)})}),i(()=>{_(e),e.asyncDep=null}),I(n),{willPerformHydration:t,hydrate:s,onHydrated:a,onCleanup:r}}function z({willPerformHydration:e,hydrate:t,onCleanup:n},r=2e3){if(!e)return;if(!f())throw new Error("useHydrateWhenIdle must be called from the setup or lifecycle hook methods.");if(!("requestIdleCallback"in window)){t();return}const o=requestIdleCallback(()=>{t()},{timeout:r});n(()=>{cancelIdleCallback(o)})}const E={ELEMENT:1,COMMENT:8},m=e=>e&&e.nodeType===E.ELEMENT,w=e=>e&&e.nodeType===E.COMMENT,S=e=>w(e)&&(e==null?void 0:e.data)==="[",F=e=>w(e)&&(e==null?void 0:e.data)==="]";function H({vnode:e,subTree:t}){if(!e||e.el===null)return[];if(m(e.el))return[e.el];const n=[];if(t&&S(t.el)&&F(t.anchor)){let r=e.el.nextSibling;for(;r;){if(r&&m(r)&&n.push(r),r===t.anchor)return n;r=r.nextSibling}}return n}function U({willPerformHydration:e,hydrate:t,onCleanup:n},r=["focus"]){if(!e)return;const o=f();if(!o||o.isMounted)throw new Error("useHydrateOnInteraction must be called from the setup method.");const s=P(r);b(()=>{const i=H(o),a=i.length>1?i[0].parentElement||document:i[0],c={capture:!0,once:!1,passive:!0},p=u=>{u.stopPropagation();const y=u.composedPath&&u.composedPath()||u.path;if(!y){let l=u.target;for(;l;){if(i.includes(l)){t();return}if(l===a)return;l=l.parentElement}return}i.forEach(l=>{y.includes(l)&&t()})};s.forEach(u=>{a.addEventListener(u,p,c)}),n(()=>{s.forEach(u=>{a.removeEventListener(u,p,c)})})})}function V({willPerformHydration:e,hydrate:t,onCleanup:n},r){if(!e)return;if(!f())throw new Error("useHydrateWhenTriggered must be called from the setup or lifecycle hook methods.");const o=T(M(r)?r:()=>r,s=>{s&&t()},{immediate:!0});n(o)}const h=new Map;function x(e){const t=typeof IntersectionObserver<"u";if(!t)return{supported:t};const n=JSON.stringify(e);if(h.has(n))return{supported:t,observer:h.get(n)};const r=new IntersectionObserver(o=>{o.forEach(s=>{!(s.isIntersecting||s.intersectionRatio>0)||!s.target.hydrate||s.target.hydrate()})},e);return h.set(n,r),{supported:t,observer:r}}function q({willPerformHydration:e,hydrate:t,onCleanup:n},r){if(!e)return;const o=f();if(!o||o.isMounted)throw new Error("useHydrateWhenVisible must be called from the setup method.");const{supported:s,observer:i}=x(r);if(!s){t();return}b(()=>{const a=H(o);a.forEach(c=>{c.hydrate=t,i.observe(c)}),n(()=>{a.forEach(c=>{delete c.hydrate,i.unobserve(c)})})})}export{z as a,q as b,U as c,V as d,j as u};
